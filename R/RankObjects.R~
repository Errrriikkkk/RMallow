
.initFoo <- function(where = '.GlobalEnv'){
  # "ranking" object.
  # "info" is column-wise comparisons
  # "ranks" is the actual ranking matrix
  # "type" tells whether the rankings are partial or full
  #       full rankings can be either, and so we need to specify.
  setClass("info", representation(info = "matrix"), prototype(matrix(0)), 
	   where = where)
  setClass("ranks", representation(ranks = "data.frame"), 
           prototype(data.frame(NULL)), where = where)
  setClass("items", representation(items = "integer"), prototype(0),
	   where = where)
  setClass("rankers", representation(rankers = "integer"), 
	   prototype(0), where = where)
  setClass("type", representation(type = "character"),
           prototype(character(0)), where = where)
  setClass("ties", representation(ties = "matrix"),
           prototype(matrix(0)), where = where)
  setClass("geqties", representation(geqties = "matrix"),
           prototype(matrix(0)), where = where)
  setClass("relative", representation(relative = "matrix"),
           prototype(numeric(0)), where = where)
  setClass("V", representation(V = "matrix"),
           prototype(numeric(0)), where = where)
  setClass("ranking", 
           contains = c("ranks", "info", "type", "ties",
                        "geqties", "relative", "V", 
                        "items", "rankers"), where = where)
  setGeneric('ranks', function(object) standardGeneric('ranks'), 
             where = where)
  # Accessor Methods on rankings
  setMethod('ranks', signature = 'ranking',
            function(object) {
              object@ranks
            }, where = where)
  
  setGeneric('type', function(object) standardGeneric('type'), where = where)
  setMethod('type', signature = 'ranking',
            function(object) {
              object@type
            }, where = where)
  setGeneric('ties', function(object) standardGeneric('ties'))
  setMethod('ties', signature = 'ranking',
            function(object) {
              object@ties
            })
  setGeneric('info', function(object) standardGeneric('info'))
  setMethod('info', signature = 'ranking',
            function(object) {
              object@info
            })
  setGeneric('geqties', function(object) standardGeneric('geqties'))
  setMethod('geqties', signature = 'ranking',
            function(object) {
              object@geqties
            })
  setGeneric('relative', function(object) standardGeneric('relative'))
  setMethod('relative', signature = 'ranking',
            function(object) {
              object@relative
            })
  setGeneric('items', function(object) standardGeneric('items'),
             where = where)
  setMethod('items', signature = 'ranking',
            function(object) {
              object@items
            }, where = where)
  setGeneric('rankers', function(object) standardGeneric('rankers'),
             where = where)
  setMethod('rankers', signature = 'ranking',
            function(object) {
              object@rankers
            }, where = where)
  setGeneric('V', function(object) standardGeneric('V'))
  setMethod('V', signature = 'ranking',
            function(object) {
              object@V
            })
  
  # "mallows" object
  # "ranking" is as above
  # "modes" are the modal sequences in the data
  # "props" is the proportion designated to each cluster
  # "lambda" is the lambda parameters of each cluster
  # "log.like" is the log likelihood throughout the model fitting
  # "clust" are the cluster assignments for each ranker
  # "dists" are the distances from each cluster center
  # "pvals" are the probabilities that each ranker is in each cluster
  setClass("modes", representation(modes = "matrix"),
           prototype(matrix(numeric(0))))
  setClass("props", representation(props = "numeric"),
           prototype(numeric(0)))
  setClass("theta", representation(theta = "matrix"),
           prototype(matrix(numeric(0))))
  setClass("normalize", representation(normalize = "numeric"),
           prototype(numeric(0)))
  setClass("log.like", representation(log.like = "numeric"),
           prototype(numeric(0)))
  setClass("clust", representation(clust = "numeric"),
           prototype(numeric(0)))
  setClass("dists", representation(dists = "matrix"),
           prototype(matrix(0)))
  setClass("pvals", representation(pvals = "matrix"),
           prototype(matrix(0)))
  setClass("mallow", contains = c("ranking", "modes", "props", 
                                  "theta", "log.like", "clust", 
                                  "dists", "pvals"))
  setGeneric('modes', function(object) standardGeneric('modes'))
  setMethod('modes', signature = 'mallow',
            function(object) {
              object@modes
            })
  setGeneric('pvals', function(object) standardGeneric('pvals'))
  setMethod('pvals', signature = 'mallow',
            function(object) {
              object@pvals
            })
  setGeneric('props', function(object) standardGeneric('props'))
  setMethod('props', signature = 'mallow',
            function(object) {
              object@props
            })
  setGeneric('theta', function(object) standardGeneric('theta'))
  setMethod('theta', signature = 'mallow',
            function(object) {
              object@theta
            })
  setGeneric('log.like', function(object) standardGeneric('log.like'))
  setMethod('log.like', signature = 'mallow',
            function(object) {
              object@log.like
            })
  setGeneric('clust', function(object) standardGeneric('clust'))
  setMethod('clust', signature = 'mallow',
            function(object) {
              object@clust
            })
  setGeneric('dists', function(object) standardGeneric('dists'))
  setMethod('dists', signature = 'mallow',
            function(object) {
              object@dists
            })
  
  # Calculate tie group size for individual rankings
  setGeneric("tieInfo", function(ranks) {
    standardGeneric("tieInfo")
  })
  setMethod("tieInfo",
            signature = "ranking",
            function(ranks) {
              top <- max(ranks@ranks)
              tie.mat <- matrix(0, nrow = rankers(ranks), ncol = top)
              for(i in 1:top) {
                tie.mat[, i] <- apply(ranks@ranks, 1, function(j) length(which(j == i)))
              }
              ranks@ties <- tie.mat
              return(ranks)
            })
  setGeneric("relativeRank", function(ranks) {
    standardGeneric("relativeRank")
  })
  setMethod("relativeRank", signature = "ranking", 
            function(ranks) {
              N <- rankers(ranks)
              n <- items(ranks)
              temp <- ranks@ranks
              out <- matrix(0, nrow = N, ncol = n)
              for(i in 1:N) {
                n <- max(temp[i, ])
                for(j in 1:n) {
                  ind <- which(temp[i, ] == j)
                  out[i, ind] <- length(ind) - (1:length(ind)) + 1
                }
              }
              return(out)
            })
  setGeneric("findV", function(ranks) {
    standardGeneric("findV")
  })
  setMethod("findV",
            signature = "ranking",
            function(ranks) {
              temp <- info(ranks)
              n <- items(ranks)
              N <- rankers(ranks)
              V <- matrix(0, nrow = N, ncol = n - 1)
              for(j in 1:(n - 1)) {
                if (j < (n - 1)) {
                  ind <- 1:(n - j)
                  V[, j] <- rowSums(temp[, ind], na.rm = TRUE)
                  temp <- temp[, -ind]
                }
                else {
                  V[, j] <- temp
                }
              }
              ranks@V <- V
              return(ranks)
            })
  # Calculate the number of tie groups in the data of size >= i
  setGeneric("geqInfo", function(ranks) {
    standardGeneric("geqInfo")
  })
  setMethod("geqInfo",
            signature = "ranking",
            function(ranks) {
              top <- ncol(ranks@ranks) # Greatest possible number of tie groups
              geq.mat <- matrix(0, nrow = rankers(ranks),
                                ncol = top)
              for(i in 1:top) {
                geq.mat[, i] <- apply(ranks@ties, 1, function(j) length(which(j >= i)))
              }
              ranks@geqties <- geq.mat
              return(ranks)
            })
  setGeneric("initialize")
  # Initialize a ranking object
  setMethod(f = "initialize",
            signature = "ranking",
            function(.Object, object, meaning = NULL) {
              if(!missing(object)) {
                .Object@items <- ncol(object)
                .Object@rankers <- nrow(object)
                temp <- simplifySequences(as.matrix(object))
                .Object@ranks <- data.frame(temp)
                if(all(diff(rowSums(.Object@ranks)) == 0)) {
                  .Object@type <- "full"
                  if(is.null(meaning)) {
                    cat("Meaning of rankings is ambiguous, defaulting to direct\n")
                  }
                  else if (meaning == "inverse") {
                    cat("Converted rankings from inverse form to direct form\n")
                    .Object@ranks <- data.frame(t(apply(.Object@ranks, 1, order)))
                  }
                }
                else {
                  .Object@type <- "partial"
                }
                .Object <- tieInfo(.Object)
                .Object <- geqInfo(.Object)
                .Object@info <- kendallInfo(ranks(.Object))
                .Object@relative <- relativeRank(.Object)
                .Object <- findV(.Object)
              }
              return(.Object)
            })
  
  setMethod("initialize", 
            signature = 'mallow',
            function(.Object, object, modes = matrix(numeric(0)), 
                     props = numeric(0), theta = matrix(numeric(0)), 
                     log.like = numeric(0), clust = numeric(0), 
                     dists = matrix(0), pvals = matrix(0)) {
              .Object@ranks <- object@ranks
              .Object@info <- object@info
              .Object@type <- object@type
              .Object@ties <- object@ties
              .Object@geqties <- object@geqties
              .Object@items <- object@items
              .Object@rankers <- object@rankers
              .Object@modes <- modes
              .Object@props <- props
              .Object@theta <- theta
              .Object@log.like <- log.like
              .Object@clust <- clust
              .Object@dists <- dists
              .Object@pvals <- pvals
              return(.Object)
            })
  # Instructions on how to show a ranking object
  setMethod("show", "ranking",
            function(object) {
              cat(cat(paste("Ranking objects on", type(object), "rankings with", 
                            rankers(object), "rankers and",
                            items(object), "items ranked.")))
            })
  # How to show a Mallows Model
  setMethod("show", "mallow", 
            function(object){
              cat(paste("Mallows model on", type(object), "rankings with\n"))
              cat(paste("Subjects:", rankers(object)), "\n")
              cat(paste("Items Ranked:", items(object)), "\n")
              cat("Modes (direct): \n")
              temp <- modes(object)
              temp <- apply(temp, 1, order)
              print(matrix(names(ranks(object))[temp], nrow = nrow(modes(object)),
                           byrow = TRUE))
              cat("Thetas: \n")
              print(theta(object))
              cat("\nProportions:\n")
              print(props(object))
            })
}
